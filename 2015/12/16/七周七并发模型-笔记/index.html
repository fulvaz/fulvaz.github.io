<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="Fulvaz"><meta name="description" content="我只是个混github连击的"><title>&lt;七周七并发模型&gt;笔记 | Fulvaz PlayGroud</title><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="Fulvaz PlayGroud" type="application/atom.xml"><link href="http://fonts.googleapis.com/css?family=Open+Sans:400" rel="stylesheet"><link href="http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/stylesheets/app.css"></head><body><section id="top-head"><div id="top-head-wraper"><a href="/">Fulvaz PlayGroud</a><div id="top-head-menu-button"></div></div></section><header id="page-header"><div class="header-background-container"><video loop="true" mute="true" autoplay="true" poster="http://7xp7jw.com1.z0.glb.clouddn.com/static/myTheme//images/header-background.jpg" class="header-background-video"><source src="http://7xp7jw.com1.z0.glb.clouddn.com/static/myTheme//videos/Blurry-Lights.webm" type="video/webm"/><source src="http://7xp7jw.com1.z0.glb.clouddn.com/static/myTheme//videos/Blurry-Lights.mp4" type="video/mp4"/><source src="http://7xp7jw.com1.z0.glb.clouddn.com/static/myTheme//videos/Blurry-Lights.ogv" type="video/ogv"/></video><div class="header-background-shelter"></div></div><div id="masthead"><div class="wrapper"><h1 id="site-title"><a href="/">Fulvaz PlayGroud</a></h1><p id="description">我只是个混github连击的</p></div></div></header><section id="content"><article class="post"><div class="article-head"><h2 class="article-title">&lt;七周七并发模型&gt;笔记</h2><div class="meta article-date">2015-12-16</div></div><div class="article-content"><p><h1 id="chp2"><a href="#chp2" class="headerlink" title="chp2"></a>chp2</h1><h2 id="共享变量解决冲突"><a href="#共享变量解决冲突" class="headerlink" title="共享变量解决冲突"></a>共享变量解决冲突</h2><p><strong>加锁</strong></p>
<p><strong>多个共享资源</strong><br>加多个锁,但加多个锁必然可能导致死锁</p>
<p><strong>死锁</strong><br>保证上锁顺序</p>
<p><strong>外星方法</strong><br>即调用者不知道其实现的方法</p>
<p>问题:如果调用者已经加锁,再调用外星方法,这个方法如果有锁,就很有可能死锁,解决方法是调用方法前对调用者进行一次保护性复制(对象),然后在进行调用</p>
<h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><p><strong>使用ReentrantLock</strong><br>锁有超时事件,超时会放弃所拥有的锁</p>
<p>但是这样并不能完全解决死锁问题,这种方案会产生活锁现象,当所有死锁同时超时,那么下次再获得锁时,很有可能会继续死锁</p>
<p>通过设置不同的超时事件可以减少活锁的概念</p>
<p>###交替锁</p>
<p>###条件锁</p>
<p>###原子变量<br>atomic包</p>
<p>###自学内容</p>
<p>###公平锁与非公平锁<br>公平锁: 线程按照先来后到的方式获取锁<br>非公平: 线程竞争,没获取到锁的线程会被压进队列,但是,压进队列的线程依旧会被后到的线程抢到锁</p>
<p>公平锁和非公平锁的区别是性能,非公平锁的性能回事公平锁的5~10倍<br>(数据来源: <a href="http://www.majin163.com/2014/03/17/synchronized2/" target="_blank" rel="external">http://www.majin163.com/2014/03/17/synchronized2/</a>)</p>
<p>###虚假唤醒(spurious wakeup)<br>就算没人调用signal,await还是有可能会被调用</p>
<p>所以用while等待条件满足唤醒,就算被虚假唤醒了,因为要判断一次条件,所以也能避免虚假唤醒造成的问题</p>
<p>###为什么synchronize比reentrantlock慢<br>因为syn是悲观锁,reentrantlock是乐观锁</p>
<blockquote>
<p>独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低<br><a href="http://blog.csdn.net/natian306/article/details/18504111" target="_blank" rel="external">http://blog.csdn.net/natian306/article/details/18504111</a></p>
</blockquote>
<h1 id="最佳方案"><a href="#最佳方案" class="headerlink" title="最佳方案"></a>最佳方案</h1><h2 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h2><p>实际使用中极少会直接创建线程</p>
<p>线程池大小?</p>
</p></div></article></section><nav id="article-list-pagination"><a href="/2015/12/16/基于ubuntu-anyconnect服务器搭建/" title="上一页 article: 基于ubuntu anyconnect服务器搭建" class="prev">&larr; 上一页</a><a href="/2015/12/16/Golang内存模型-嚼过的笔记/" title="下一页 article: &lt;Golang内存模型&gt; 嚼过的笔记" class="next">下一页 &rarr;</a></nav><footer id="page-footer"><section><nav id="footer-menu"><ul><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="https://github.com/subuta/hexo-jade-sass-barebone">Source</a></li></ul></nav></section></footer></body></html>