<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="Fulvaz"><meta name="description" content="我只是个混github连击的"><title>Fulvaz PlayGroud</title><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="Fulvaz PlayGroud" type="application/atom.xml"><link href="http://fonts.lug.ustc.edu.cn/css?family=Open+Sans:400" rel="stylesheet"><link href="http://fonts.lug.ustc.edu.cn/css?family=Source+Code+Pro:400,600" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/stylesheets/app.css"></head><body><nav class="slide-menu"><div class="container"><div id="slide-introduction"><section id="slide-avator"></section><section id="slide-name"><p>Fulvaz</p></section><section id="slide-introduction-content"><p>半路出家伪文艺码农</p></section><section id="slide-contacts"></section></div><ul><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="https://github.com/subuta/hexo-jade-sass-barebone">Source</a></li></ul></div></nav><section id="top-head"><div id="top-head-wraper"><a href="/">Fulvaz PlayGroud</a><i id="top-head-menu-button" aria-hidden="true" class="fa fa-bars"></i></div></section><div class="wrapper"><header id="page-header"><div class="header-background-container"><video loop="true" mute="true" autoplay="true" poster="http://7xp7jw.com1.z0.glb.clouddn.com/myTheme/static/images/header-background.jpg" class="header-background-video"><source src="http://7xp7jw.com1.z0.glb.clouddn.com/myTheme/static/videos/Blurry-Lights.webm" type="video/webm"><source src="http://7xp7jw.com1.z0.glb.clouddn.com/myTheme/static/videos/Blurry-Lights.mp4" type="video/mp4"><source src="http://7xp7jw.com1.z0.glb.clouddn.com/myTheme/static/videos/Blurry-Lights.ogv" type="video/ogv"></video></div><div class="header-background-shelter"></div><div id="masthead"><div class="wrapper"><h1 id="site-title">Fulvaz PlayGroud</h1><p id="description">我只是个混github连击的</p></div></div></header><section id="content"><ul class="article-list"><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2016/06/09/实现向下滚动文章逐渐显示动画/">实现向下滚动文章逐渐显示动画</a></h2><div class="meta article-date">2016-06-09</div></div><!-- abstract--><div class="article-content markdown-body"><p>其实基本参考文末链接文章做的, 只是那篇文章实在写得太简略, 我将文章扩展开</p></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2016/06/02/haha/">haha</a></h2><div class="meta article-date">2016-06-02</div></div><!-- abstract--><div class="article-content markdown-body"><img title="图片标题" alt="图片说明" class="class1 class2" src="http://7xp7jw.com1.z0.glb.clouddn.com/static/images/test.jpg?imageView2/2/w/600">
<a id="more"></a></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2016/06/02/javascript精粹读书笔记/">javascript精粹读书笔记</a></h2><div class="meta article-date">2016-06-02</div></div><!-- abstract--><div class="article-content markdown-body"><blockquote>
<p>快速说明: 这本书在今天(2016年06月02日)实在是已经过时了, 我这里记录下可以一看的内容, </p>
<p>吐槽: 研究原型继承很蠢, ES6已经实现了class, 其用法比其实现更重要. 另外, 函数式编程是另一种更恰当的方案</p>
<p>吐槽2: 这本书的作者不知道为什么非常热衷于修改自带类型的方法(比如Array)……会踩坑的好吧!</p>
</blockquote>
<a id="more"></a>
<p>级联</p>
<hr>
<p>每次操作完都返回同一个对象 (java玩烂了)!</p>
<p>Curry</p>
<hr>
<p>返回一个定制函数, 供后面调用</p>
<p>Memoize</p>
<hr></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2016/03/02/再见2015-我的进宅脱宅之旅/">再见2015 - 我的进宅脱宅之旅</a></h2><div class="meta article-date">2016-03-02</div></div><!-- abstract--><div class="article-content markdown-body"><blockquote>
<p>事先声明: 是标题党</p>
</blockquote>
<a id="more"></a>
<h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p>去年从5月开始就一直宅在宿舍了, 起先是因为下雨不想出门, 后来以效率为借口不想出门, 直到我发现我性格出现了变化, 才明白: 宅出事了.</p>
<p>特别是这篇文章, 让我深深感到后怕<br><code>http://daily.zhihu.com/story/7928517?utm_campaign=in_app_share&amp;utm_medium=iOS&amp;utm_source=weixin&amp;from=timeline&amp;isappinstalled=1</code></p>
<p>坏消息是, 我明白得有点晚, 好消息是, 我明白了</p>
<h2 id="上课"><a href="#上课" class="headerlink" title="上课"></a>上课</h2><p>如果总结自己研究生第一学期, 那就是上课, 无穷无尽的课程, 导师的培养方式非常别致, 让我去上课, 上上上上, 起先挺好的, 我感觉进入了一个个新的世界, 只想当码农的程序员不是好工程师. 然而后面事情就不对头了, 诶, 怎么老觉得都是浮在空中的理论, 而无法降落到地面呢? 拓荒!</p>
<h2 id="野人"><a href="#野人" class="headerlink" title="野人"></a>野人</h2><p>一个词即可概括我的研二上学期生活: 野人. 野到什么程度呢? 老师都快要忘记我了, 非常纳闷地问我, 你怎么不积极了呢? 虽然我也很想回答他怎么回事, 但我还是笑笑糊弄过去了, 宝宝心里苦, 可我就是不说. 但是也算长了见识吧.</p></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2015/12/19/Machine-Learning-Week3/">Machine Learning Week3</a></h2><div class="meta article-date">2015-12-19</div></div><!-- abstract--><div class="article-content markdown-body"><p>我也不知道为啥hexo会无法转换这篇笔记<br>看这吧<br><a href="http://fulvaz.leanote.com/post/Machine-learning" target="_blank" rel="external">http://fulvaz.leanote.com/post/Machine-learning</a></p>
</div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2015/12/19/Machine-Learning-Week01-02/">Machine Learning | Week01 &amp; 02</a></h2><div class="meta article-date">2015-12-19</div></div><!-- abstract--><div class="article-content markdown-body"><h1 id="Week-01"><a href="#Week-01" class="headerlink" title="Week 01"></a>Week 01</h1><hr>
<h1 id="supervisor-learning"><a href="#supervisor-learning" class="headerlink" title="supervisor learning"></a>supervisor learning</h1><p>are given a data set and already know what our correct output should look like<br>unsupervise leanring</p>
<h2 id="regression-problem"><a href="#regression-problem" class="headerlink" title="regression problem"></a>regression problem</h2><p>predict result with <strong>continuous</strong> output</p>
<h2 id="classification-problem"><a href="#classification-problem" class="headerlink" title="classification problem"></a>classification problem</h2><p>predict in <strong>discrete</strong> categories</p>
<h1 id="unsupervisor-learning"><a href="#unsupervisor-learning" class="headerlink" title="unsupervisor learning"></a>unsupervisor learning</h1><p>我们有一堆数据,但是我们自己也不知道会产生什么结果,我们用算法produce结果</p></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2015/12/17/硬盘被误操作格了之后/">硬盘被误操作格了之后</a></h2><div class="meta article-date">2015-12-17</div></div><!-- abstract--><div class="article-content markdown-body"><h1 id="硬盘被格了"><a href="#硬盘被格了" class="headerlink" title="硬盘被格了"></a>硬盘被格了</h1><p>对的,在重装ubuntu时,我按了一个叫『LVM blabla』的选项,等我进入分区选择时,我意识到了问题不对: 我的分区呢?</p>
<p>不死心的我直接重启电脑，嗯，忽然想起自己u盘和电脑不兼容，刚才用的是硬盘引导，这下问题大条了。</p>
<h1 id="这次丢了啥？"><a href="#这次丢了啥？" class="headerlink" title="这次丢了啥？"></a>这次丢了啥？</h1><h2 id="代码！"><a href="#代码！" class="headerlink" title="代码！"></a>代码！</h2><p>对，丢了不少代码，不过不知道值得庆幸还是悲哀，作为一个菜鸡，写过的代码全是demo，虽然都是js和golang的代码……嗯……还能接受。最关键的是这几天的工作，装逼如我，提交到github上了，（我觉得今年最明智的选择就是学习了git）clone回来就行，啥事都没有，那堆远古代码也在网盘有备份。那就是我损失了一堆新学习的demo。</p>
<p>##blog！<br>对，就是我这个blog，本地hexo文件被清了。好消息是我习惯先在leanote上写好文章，然后再发布到github page，那就是说，去leanote上能找回文章备份。<br>比较烦心的就是我要重新搭建hexo，装nodejs，装cnpm，配置，装deploy插件，换主题，小修改………文章量比较小，很快就恢复了。</p>
<p>当然为了以防万一，我还是在github建了个私有仓库备份了blog的源码。</p>
<h2 id="论文！"><a href="#论文！" class="headerlink" title="论文！"></a>论文！</h2><p>嘿嘿，老夫用mendeley，云同步，加上我研究问题喜欢记log，重新下也可以。</p></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2015/12/16/基于ubuntu-anyconnect服务器搭建/">基于ubuntu anyconnect服务器搭建</a></h2><div class="meta article-date">2015-12-16</div></div><!-- abstract--><div class="article-content markdown-body"><h1 id="零点零-快速阅读"><a href="#零点零-快速阅读" class="headerlink" title="零点零 快速阅读"></a>零点零 快速阅读</h1><p>本文和其他方案最大的不同是加入TUN和cert-user-oid,如果你用其他方法错误,可以看看本文,本文旨在不越狱在ios下科学上网</p>
<h1 id="零-可用方案"><a href="#零-可用方案" class="headerlink" title="零 可用方案"></a>零 可用方案</h1><h2 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h2><p>首先就排除了这个方案,因为客户端在ios9不能用</p>
<h2 id="pac代理"><a href="#pac代理" class="headerlink" title="pac代理"></a>pac代理</h2><p>可以利用25端口进行http代理,问题是速度慢100~200k,安全性太差(有来源,但是找不到了)</p>
<h2 id="Ikev2"><a href="#Ikev2" class="headerlink" title="Ikev2"></a>Ikev2</h2><p>一切都是美好的,直到我发现需要用mac来生成配置文件</p>
<h2 id="利用ocserv部署anyconnect"><a href="#利用ocserv部署anyconnect" class="headerlink" title="利用ocserv部署anyconnect"></a>利用ocserv部署anyconnect</h2></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2015/12/16/七周七并发模型-笔记/">&lt;七周七并发模型&gt;笔记</a></h2><div class="meta article-date">2015-12-16</div></div><!-- abstract--><div class="article-content markdown-body"><h1 id="chp2"><a href="#chp2" class="headerlink" title="chp2"></a>chp2</h1><h2 id="共享变量解决冲突"><a href="#共享变量解决冲突" class="headerlink" title="共享变量解决冲突"></a>共享变量解决冲突</h2><p><strong>加锁</strong></p>
<p><strong>多个共享资源</strong><br>加多个锁,但加多个锁必然可能导致死锁</p>
<p><strong>死锁</strong><br>保证上锁顺序</p>
<p><strong>外星方法</strong><br>即调用者不知道其实现的方法</p>
<p>问题:如果调用者已经加锁,再调用外星方法,这个方法如果有锁,就很有可能死锁,解决方法是调用方法前对调用者进行一次保护性复制(对象),然后在进行调用</p>
<h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><p><strong>使用ReentrantLock</strong><br>锁有超时事件,超时会放弃所拥有的锁</p>
<p>但是这样并不能完全解决死锁问题,这种方案会产生活锁现象,当所有死锁同时超时,那么下次再获得锁时,很有可能会继续死锁</p></div></article></li><li class="reveal-detect article-container"><article><div class="article-head"><h2 class="article-title"><a href="/2015/12/16/Golang内存模型-嚼过的笔记/">&lt;Golang内存模型&gt; 嚼过的笔记</a></h2><div class="meta article-date">2015-12-16</div></div><!-- abstract--><div class="article-content markdown-body"><h1 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens Before"></a>Happens Before</h1><p>操作内存的局部顺序</p>
<p>如果r可以读取到v被w修改,那么需要满足两个条件</p>
<ol>
<li>r不能在w之前进行</li>
<li>没有其他w`在w后,r前,修改了v</li>
</ol>
<p>为了保证r对特定w的观察,要保证r只能观察w,即</p>
<ol>
<li>w在r前发生</li>
<li>其他w`要么在w前发生,要么在r后发生</li>
</ol>
<p>后一条件更强</p>
<p>ps1: 对v初始化也是个w<br>ps2: 读写超过a single machine word的值,读写顺序是乱序的</p>
<h1 id="Synchronization"><a href="#Synchronization" class="headerlink" title="Synchronization"></a>Synchronization</h1><h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2></div></article></li></ul></section><footer id="page-footer"><nav id="footer-menu"><ul><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="https://github.com/fulvaz/hexo-theme">Source</a></li></ul></nav></footer></div><script src="/script/futil_min.js"></script><script src="/script/app_0.1_min.js"></script></body></html>